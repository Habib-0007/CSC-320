Directory structure:
└── src/
    ├── app.js
    ├── config/
    │   └── db.js
    ├── controllers/
    │   ├── authController.js
    │   ├── documentController.js
    │   ├── questionController.js
    │   └── ragController.js
    ├── middleware/
    │   ├── authMiddleware.js
    │   └── errorMiddleware.js
    ├── models/
    │   ├── documentModel.js
    │   ├── questionModel.js
    │   └── userModel.js
    ├── routes/
    │   ├── authRoutes.js
    │   ├── documentRoutes.js
    │   ├── questionRoutes.js
    │   └── ragRoutes.js
    ├── services/
    │   ├── aiService.js
    │   └── vectorService.js
    └── utils/
        ├── emailService.js
        ├── fileProcessing.js
        └── tokenUtils.js

================================================
FILE: server/src/app.js
================================================
import express from "express";
// import multer from "multer";
import cors from "cors";
import dotenv from "dotenv";
import { connectDB } from "./config/db.js";
import { errorHandler } from "./middleware/errorMiddleware.js";
import authRoutes from "./routes/authRoutes.js";
import documentRoutes from "./routes/documentRoutes.js";
import questionRoutes from "./routes/questionRoutes.js";
import ragRoutes from "./routes/ragRoutes.js";

// Load environment variables
dotenv.config();

// Initialize Express app
const app = express();
const PORT = process.env.PORT || 3001;

// Connect to MongoDB
connectDB();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/documents", documentRoutes);
app.use("/api/questions", questionRoutes);
app.use("/api/rag", ragRoutes);

// Error handling middleware
app.use(errorHandler);

// Start server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

export default app;



================================================
FILE: server/src/config/db.js
================================================
import mongoose from "mongoose";

export const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1);
  }
};



================================================
FILE: server/src/controllers/authController.js
================================================
import crypto from "crypto";
import User from "../models/userModel.js";
import { asyncHandler, AppError } from "../middleware/errorMiddleware.js";
import { generateToken, generateRefreshToken } from "../utils/tokenUtils.js";
import {
  sendPasswordResetEmail,
  sendWelcomeEmail,
} from "../utils/emailService.js";

// @desc    Register user
// @route   POST /api/auth/register
// @access  Public
export const registerUser = asyncHandler(async (req, res) => {
  const { name, email, password } = req.body;

  // Check if user exists
  const userExists = await User.findOne({ email });

  if (userExists) {
    throw new AppError("User already exists", 400);
  }

  // Create user
  const user = await User.create({
    name,
    email,
    password,
  });

  if (user) {
    // Send welcome email
    await sendWelcomeEmail(email, name);

    res.status(201).json({
      _id: user._id,
      name: user.name,
      email: user.email,
      token: generateToken(user._id),
      refreshToken: generateRefreshToken(user._id),
    });
  } else {
    throw new AppError("Invalid user data", 400);
  }
});

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
export const loginUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  // Check for user email
  const user = await User.findOne({ email }).select("+password");

  if (!user || !(await user.matchPassword(password))) {
    throw new AppError("Invalid credentials", 401);
  }

  res.json({
    _id: user._id,
    name: user.name,
    email: user.email,
    token: generateToken(user._id),
    refreshToken: generateRefreshToken(user._id),
  });
});

// @desc    Get user profile
// @route   GET /api/auth/profile
// @access  Private
export const getUserProfile = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user._id);

  if (user) {
    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt,
    });
  } else {
    throw new AppError("User not found", 404);
  }
});

// @desc    Update user profile
// @route   PUT /api/auth/profile
// @access  Private
export const updateUserProfile = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user._id);

  if (user) {
    user.name = req.body.name || user.name;
    user.email = req.body.email || user.email;

    if (req.body.password) {
      user.password = req.body.password;
    }

    const updatedUser = await user.save();

    res.json({
      _id: updatedUser._id,
      name: updatedUser.name,
      email: updatedUser.email,
      token: generateToken(updatedUser._id),
    });
  } else {
    throw new AppError("User not found", 404);
  }
});

// @desc    Forgot password
// @route   POST /api/auth/forgot-password
// @access  Public
export const forgotPassword = asyncHandler(async (req, res) => {
  const { email } = req.body;

  // Find user by email
  const user = await User.findOne({ email });

  if (!user) {
    throw new AppError("User with that email does not exist", 404);
  }

  // Generate reset OTP
  const resetOTP = user.generateResetOTP();
  await user.save();

  try {
    // Send email with reset OTP
    await sendPasswordResetEmail(user.email, resetOTP, user.name);

    res.json({
      success: true,
      message: "OTP sent to email",
      email: user.email,
    });
  } catch (error) {
    user.resetPasswordOTP = undefined;
    user.resetPasswordOTPExpire = undefined;
    await user.save();

    throw new AppError("Email could not be sent", 500);
  }
});

// @desc    Verify OTP
// @route   POST /api/auth/verify-otp
// @access  Public
export const verifyOTP = asyncHandler(async (req, res) => {
  const { email, otp } = req.body;

  // Hash OTP
  const resetPasswordOTP = crypto
    .createHash("sha256")
    .update(otp)
    .digest("hex");

  // Find user with matching OTP and non-expired OTP
  const user = await User.findOne({
    email,
    resetPasswordOTP,
    resetPasswordOTPExpire: { $gt: Date.now() },
  });

  if (!user) {
    throw new AppError("Invalid or expired OTP", 400);
  }

  res.json({
    success: true,
    message: "OTP verified successfully",
    email: user.email,
  });
});

// @desc    Reset password
// @route   POST /api/auth/reset-password
// @access  Public
export const resetPassword = asyncHandler(async (req, res) => {
  const { email, otp, password } = req.body;

  // Hash OTP
  const resetPasswordOTP = crypto
    .createHash("sha256")
    .update(otp)
    .digest("hex");

  // Find user with matching OTP and non-expired OTP
  const user = await User.findOne({
    email,
    resetPasswordOTP,
    resetPasswordOTPExpire: { $gt: Date.now() },
  });

  if (!user) {
    throw new AppError("Invalid or expired OTP", 400);
  }

  // Set new password
  user.password = password;
  user.resetPasswordOTP = undefined;
  user.resetPasswordOTPExpire = undefined;
  await user.save();

  res.json({
    success: true,
    message: "Password reset successful",
    token: generateToken(user._id),
    refreshToken: generateRefreshToken(user._id),
  });
});

// @desc    Refresh token
// @route   POST /api/auth/refresh-token
// @access  Public
export const refreshToken = asyncHandler(async (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    throw new AppError("Refresh token is required", 400);
  }

  try {
    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

    // Generate new access token
    const accessToken = generateToken(decoded.id);

    res.json({
      token: accessToken,
    });
  } catch (error) {
    throw new AppError("Invalid refresh token", 401);
  }
});



================================================
FILE: server/src/controllers/documentController.js
================================================
import multer from "multer";
import Document from "../models/documentModel.js";
import { asyncHandler, AppError } from "../middleware/errorMiddleware.js";
import { processFile, saveFileToDisk } from "../utils/fileProcessing.js";
import { chunkText, generateEmbedding } from "../services/vectorService.js";

// Configure multer for memory storage
const storage = multer.memoryStorage();
export const upload = multer({
  storage,
  limits: { fileSize: 20 * 1024 * 1024 }, // 20MB file size limit
});

// @desc    Upload document
// @route   POST /api/documents/upload
// @access  Private
export const uploadDocument = asyncHandler(async (req, res) => {
  if (!req.files || req.files.length === 0) {
    throw new AppError("No files uploaded", 400);
  }

  const results = [];

  // Process each uploaded file
  for (const file of req.files) {
    // Extract text based on file type
    const extractedText = await processFile(file);

    // Save file to disk
    const fileInfo = await saveFileToDisk(file, req.user._id);

    // Create document record in database
    const document = await Document.create({
      user: req.user._id,
      title: req.body.title || file.originalname,
      originalFileName: fileInfo.originalFileName,
      fileType: fileInfo.fileType,
      fileSize: fileInfo.fileSize,
      storagePath: fileInfo.storagePath,
      extractedText,
    });

    results.push({
      _id: document._id,
      title: document.title,
      fileType: document.fileType,
      fileSize: document.fileSize,
      originalFileName: document.originalFileName,
      createdAt: document.createdAt,
    });
  }

  res.status(201).json({
    success: true,
    count: results.length,
    data: results,
  });
});

// @desc    Create document vectors
// @route   POST /api/documents/:id/vectorize
// @access  Private
export const vectorizeDocument = asyncHandler(async (req, res) => {
  const document = await Document.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!document) {
    throw new AppError("Document not found", 404);
  }

  if (document.vectorized) {
    throw new AppError("Document is already vectorized", 400);
  }

  // Chunk the document text
  const textChunks = chunkText(document.extractedText);

  // Generate embeddings for each chunk
  // For this implementation, we're just marking the document as vectorized
  // In a production environment, you'd store these embeddings in a vector database
  document.vectorized = true;
  await document.save();

  res.json({
    success: true,
    message: "Document vectorized successfully",
    docId: document._id,
  });
});

// @desc    Get all documents
// @route   GET /api/documents
// @access  Private
export const getDocuments = asyncHandler(async (req, res) => {
  const documents = await Document.find({ user: req.user._id })
    .select("-extractedText")
    .sort({ createdAt: -1 });

  res.json({
    success: true,
    count: documents.length,
    data: documents,
  });
});

// @desc    Get document by ID
// @route   GET /api/documents/:id
// @access  Private
export const getDocumentById = asyncHandler(async (req, res) => {
  const document = await Document.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!document) {
    throw new AppError("Document not found", 404);
  }

  res.json({
    success: true,
    data: document,
  });
});

// @desc    Update document
// @route   PUT /api/documents/:id
// @access  Private
export const updateDocument = asyncHandler(async (req, res) => {
  const { title } = req.body;

  const document = await Document.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!document) {
    throw new AppError("Document not found", 404);
  }

  document.title = title || document.title;
  await document.save();

  res.json({
    success: true,
    data: document,
  });
});

// @desc    Delete document
// @route   DELETE /api/documents/:id
// @access  Private
export const deleteDocument = asyncHandler(async (req, res) => {
  const document = await Document.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!document) {
    throw new AppError("Document not found", 404);
  }

  await document.deleteOne();

  res.json({
    success: true,
    message: "Document deleted",
  });
});

// @desc    Search documents
// @route   GET /api/documents/search
// @access  Private
export const searchDocuments = asyncHandler(async (req, res) => {
  const { query } = req.query;

  if (!query) {
    throw new AppError("Search query is required", 400);
  }

  // Use MongoDB text search
  const documents = await Document.find({
    user: req.user._id,
    $text: { $search: query },
  })
    .select("-extractedText")
    .sort({ score: { $meta: "textScore" } });

  res.json({
    success: true,
    count: documents.length,
    data: documents,
  });
});



================================================
FILE: server/src/controllers/questionController.js
================================================
import Document from "../models/documentModel.js";
import Question from "../models/questionModel.js";
import { asyncHandler, AppError } from "../middleware/errorMiddleware.js";
import { generateQuestions, validateAnswer } from "../services/aiService.js";

// @desc    Generate questions from document
// @route   POST /api/questions/generate/:documentId
// @access  Private
export const generateQuestionsFromDocument = asyncHandler(async (req, res) => {
  const { numQuestions = 5, difficulty = "medium" } = req.body;
  const documentId = req.params.documentId;

  // Validate input
  if (!["easy", "medium", "hard"].includes(difficulty)) {
    throw new AppError("Difficulty must be easy, medium, or hard", 400);
  }

  if (numQuestions < 1 || numQuestions > 20) {
    throw new AppError("Number of questions must be between 1 and 20", 400);
  }

  // Find document
  const document = await Document.findOne({
    _id: documentId,
    user: req.user._id,
  });

  if (!document) {
    throw new AppError("Document not found", 404);
  }

  // Generate questions using AI
  const result = await generateQuestions(
    document.extractedText,
    numQuestions,
    difficulty
  );

  if (!result.questions || result.questions.length === 0) {
    return res.json({
      success: true,
      message: "Unable to generate questions from the provided document",
      preview: result.preview,
      questions: [],
    });
  }

  // Save questions to database
  const savedQuestions = await Promise.all(
    result.questions.map(async (q) => {
      const questionDoc = await Question.create({
        user: req.user._id,
        document: document._id,
        question: q.question,
        correctAnswer: q.correctAnswer,
        difficulty: q.difficulty,
        tags: req.body.tags || [],
      });

      return {
        _id: questionDoc._id,
        question: questionDoc.question,
        difficulty: questionDoc.difficulty,
      };
    })
  );

  res.json({
    success: true,
    preview: result.preview,
    count: savedQuestions.length,
    data: savedQuestions,
  });
});

// @desc    Validate answer
// @route   POST /api/questions/:id/validate
// @access  Private
export const validateUserAnswer = asyncHandler(async (req, res) => {
  const { userAnswer } = req.body;

  if (!userAnswer) {
    throw new AppError("User answer is required", 400);
  }

  // Find question
  const question = await Question.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!question) {
    throw new AppError("Question not found", 404);
  }

  // Validate answer using AI
  const validation = await validateAnswer(
    question.question,
    question.correctAnswer,
    userAnswer
  );

  res.json({
    success: true,
    data: {
      questionId: question._id,
      result: validation.result,
      explanation: validation.explanation,
    },
  });
});

// @desc    Get questions by document
// @route   GET /api/questions/document/:documentId
// @access  Private
export const getQuestionsByDocument = asyncHandler(async (req, res) => {
  const questions = await Question.find({
    document: req.params.documentId,
    user: req.user._id,
  }).select("-correctAnswer");

  res.json({
    success: true,
    count: questions.length,
    data: questions,
  });
});

// @desc    Get all questions
// @route   GET /api/questions
// @access  Private
export const getAllQuestions = asyncHandler(async (req, res) => {
  const questions = await Question.find({
    user: req.user._id,
  })
    .select("-correctAnswer")
    .populate("document", "title");

  res.json({
    success: true,
    count: questions.length,
    data: questions,
  });
});

// @desc    Get question details
// @route   GET /api/questions/:id
// @access  Private
export const getQuestionById = asyncHandler(async (req, res) => {
  const question = await Question.findOne({
    _id: req.params.id,
    user: req.user._id,
  }).populate("document", "title");

  if (!question) {
    throw new AppError("Question not found", 404);
  }

  res.json({
    success: true,
    data: question,
  });
});

// @desc    Delete question
// @route   DELETE /api/questions/:id
// @access  Private
export const deleteQuestion = asyncHandler(async (req, res) => {
  const question = await Question.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!question) {
    throw new AppError("Question not found", 404);
  }

  await question.deleteOne();

  res.json({
    success: true,
    message: "Question deleted",
  });
});



================================================
FILE: server/src/controllers/ragController.js
================================================
import Document from "../models/documentModel.js";
import { asyncHandler, AppError } from "../middleware/errorMiddleware.js";
import { chunkText, findRelevantChunks } from "../services/vectorService.js";
import { generateRagResponse } from "../services/aiService.js";

// @desc    Chat with document
// @route   POST /api/rag/chat/:documentId
// @access  Private
export const chatWithDocument = asyncHandler(async (req, res) => {
  const { query } = req.body;
  const documentId = req.params.documentId;

  if (!query) {
    throw new AppError("Query is required", 400);
  }

  // Find document
  const document = await Document.findOne({
    _id: documentId,
    user: req.user._id,
  });

  if (!document) {
    throw new AppError("Document not found", 404);
  }

  // Chunk the document text
  const textChunks = chunkText(document.extractedText);

  // Find relevant chunks for the query
  const relevantChunks = await findRelevantChunks(query, textChunks);

  // Combine relevant chunks into context
  const context = relevantChunks.map((item) => item.chunk).join("\n\n");

  // Generate RAG response
  const response = await generateRagResponse(query, context);

  res.json({
    success: true,
    data: {
      query,
      response,
    },
  });
});

// @desc    Chat with multiple documents
// @route   POST /api/rag/chat
// @access  Private
export const chatWithMultipleDocuments = asyncHandler(async (req, res) => {
  const { query, documentIds } = req.body;

  if (!query) {
    throw new AppError("Query is required", 400);
  }

  if (!documentIds || !Array.isArray(documentIds) || documentIds.length === 0) {
    throw new AppError("Document IDs are required", 400);
  }

  // Find documents owned by the user
  const documents = await Document.find({
    _id: { $in: documentIds },
    user: req.user._id,
  });

  if (documents.length === 0) {
    throw new AppError("No valid documents found", 404);
  }

  // Collect all document content
  let allChunks = [];
  for (const doc of documents) {
    const chunks = chunkText(doc.extractedText);
    allChunks = [...allChunks, ...chunks];
  }

  // Find relevant chunks across all documents
  const relevantChunks = await findRelevantChunks(query, allChunks);

  // Combine relevant chunks into context
  const context = relevantChunks.map((item) => item.chunk).join("\n\n");

  // Generate RAG response
  const response = await generateRagResponse(query, context);

  res.json({
    success: true,
    data: {
      query,
      response,
      documentsUsed: documents.map((doc) => ({
        _id: doc._id,
        title: doc.title,
      })),
    },
  });
});



================================================
FILE: server/src/middleware/authMiddleware.js
================================================
import jwt from "jsonwebtoken";
import { asyncHandler } from "./errorMiddleware.js";
import { AppError } from "./errorMiddleware.js";
import User from "../models/userModel.js";

// Protect routes - verify token
export const protect = asyncHandler(async (req, res, next) => {
  let token;

  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    try {
      // Get token from header
      token = req.headers.authorization.split(" ")[1];

      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      // Get user from the token
      req.user = await User.findById(decoded.id).select("-password");

      if (!req.user) {
        throw new AppError("User not found", 401);
      }

      next();
    } catch (error) {
      console.error(error);
      throw new AppError("Not authorized, token failed", 401);
    }
  }

  if (!token) {
    throw new AppError("Not authorized, no token", 401);
  }
});



================================================
FILE: server/src/middleware/errorMiddleware.js
================================================
// Custom error class
export class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Error handler middleware
export const errorHandler = (err, req, res, next) => {
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    status: err.status || "error",
    message: err.message || "Internal Server Error",
    stack: process.env.NODE_ENV === "development" ? err.stack : undefined,
  });
};

// Async handler to avoid try-catch blocks
export const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};



================================================
FILE: server/src/models/documentModel.js
================================================
import mongoose from "mongoose";

const documentSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    title: {
      type: String,
      required: [true, "Please add a title"],
    },
    originalFileName: {
      type: String,
      required: true,
    },
    fileType: {
      type: String,
      required: true,
    },
    fileSize: {
      type: Number,
      required: true,
    },
    storagePath: {
      type: String,
      required: true,
    },
    extractedText: {
      type: String,
      required: true,
    },
    vectorized: {
      type: Boolean,
      default: false,
    },
    embeddingId: {
      type: String,
      default: null,
    },
  },
  { timestamps: true }
);

// Create index on extracted text for text search capabilities
documentSchema.index({ extractedText: "text" });

const Document = mongoose.model("Document", documentSchema);

export default Document;



================================================
FILE: server/src/models/questionModel.js
================================================
import mongoose from "mongoose";

const questionSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    document: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Document",
      required: true,
    },
    question: {
      type: String,
      required: true,
    },
    correctAnswer: {
      type: String,
      required: true,
    },
    difficulty: {
      type: String,
      enum: ["easy", "medium", "hard"],
      required: true,
    },
    tags: [
      {
        type: String,
      },
    ],
  },
  { timestamps: true }
);

const Question = mongoose.model("Question", questionSchema);

export default Question;



================================================
FILE: server/src/models/userModel.js
================================================
import mongoose from "mongoose";
import bcrypt from "bcryptjs";
import crypto from "crypto";

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: [true, "Please add a name"],
      trim: true,
    },
    email: {
      type: String,
      required: [true, "Please add an email"],
      unique: true,
      match: [
        /^([\w-\.]+@([\w-]+\.)+[\w-]{2,4})?$/,
        "Please add a valid email",
      ],
      lowercase: true,
    },
    password: {
      type: String,
      required: [true, "Please add a password"],
      minlength: [6, "Password must be at least 6 characters"],
      select: false,
    },
    resetPasswordOTP: String,
    resetPasswordOTPExpire: Date,
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true }
);

// Encrypt password before saving
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) {
    next();
  }

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Match password
userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

// Generate and hash OTP for password reset
userSchema.methods.generateResetOTP = function () {
  // Generate a 6-digit OTP
  const resetOTP = Math.floor(100000 + Math.random() * 900000).toString();

  // Hash the OTP
  this.resetPasswordOTP = crypto
    .createHash("sha256")
    .update(resetOTP)
    .digest("hex");

  // Set OTP expiration to 10 minutes
  this.resetPasswordOTPExpire = Date.now() + 10 * 60 * 1000;

  return resetOTP;
};

const User = mongoose.model("User", userSchema);

export default User;



================================================
FILE: server/src/routes/authRoutes.js
================================================
import express from "express";
import {
  registerUser,
  loginUser,
  getUserProfile,
  updateUserProfile,
  forgotPassword,
  verifyOTP,
  resetPassword,
  refreshToken,
} from "../controllers/authController.js";
import { protect } from "../middleware/authMiddleware.js";

const router = express.Router();

// Public routes
router.post("/register", registerUser);
router.post("/login", loginUser);
router.post("/forgot-password", forgotPassword);
router.post("/verify-otp", verifyOTP);
router.post("/reset-password", resetPassword);
router.post("/refresh-token", refreshToken);

// Protected routes
router.get("/profile", protect, getUserProfile);
router.put("/profile", protect, updateUserProfile);

export default router;



================================================
FILE: server/src/routes/documentRoutes.js
================================================
import express from "express";
import {
  uploadDocument,
  getDocuments,
  getDocumentById,
  updateDocument,
  deleteDocument,
  vectorizeDocument,
  searchDocuments,
  upload,
} from "../controllers/documentController.js";
import { protect } from "../middleware/authMiddleware.js";

const router = express.Router();

// Protected routes
router.use(protect);

router.route("/").get(getDocuments).post(upload.array("files"), uploadDocument);

router.get("/search", searchDocuments);

router
  .route("/:id")
  .get(getDocumentById)
  .put(updateDocument)
  .delete(deleteDocument);

router.post("/:id/vectorize", vectorizeDocument);

export default router;



================================================
FILE: server/src/routes/questionRoutes.js
================================================
import express from "express";
import {
  generateQuestionsFromDocument,
  validateUserAnswer,
  getQuestionsByDocument,
  getAllQuestions,
  getQuestionById,
  deleteQuestion,
} from "../controllers/questionController.js";
import { protect } from "../middleware/authMiddleware.js";

const router = express.Router();

// Protected routes
router.use(protect);

router.get("/", getAllQuestions);
router.get("/document/:documentId", getQuestionsByDocument);
router.post("/generate/:documentId", generateQuestionsFromDocument);

router.route("/:id").get(getQuestionById).delete(deleteQuestion);

router.post("/:id/validate", validateUserAnswer);

export default router;



================================================
FILE: server/src/routes/ragRoutes.js
================================================
import express from "express";
import {
  chatWithDocument,
  chatWithMultipleDocuments,
} from "../controllers/ragController.js";
import { protect } from "../middleware/authMiddleware.js";

const router = express.Router();

// Protected routes
router.use(protect);

router.post("/chat", chatWithMultipleDocuments);
router.post("/chat/:documentId", chatWithDocument);

export default router;



================================================
FILE: server/src/services/aiService.js
================================================
import { GoogleGenerativeAI } from "@google/generative-ai";
import { AppError } from "../middleware/errorMiddleware.js";

// Initialize GoogleGenerativeAI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Generate response from Gemini model
export const generateGeminiResponse = async (
  prompt,
  responseType = "application/json"
) => {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const chatSession = model.startChat({
      generationConfig: {
        temperature: 1,
        topP: 0.95,
        topK: 64,
        maxOutputTokens: 8192,
        responseMimeType: responseType,
      },
    });

    const result = await chatSession.sendMessage(prompt);
    return responseType === "application/json"
      ? JSON.parse(result.response.text())
      : result.response.text();
  } catch (error) {
    console.error("Error with Gemini Chat API:", error);
    throw new AppError("Failed to generate response using Gemini API", 500);
  }
};

// Generate questions from document content
export const generateQuestions = async (content, numQuestions, difficulty) => {
  const prompt = `
    Based on the following document content:
    ${content}
    
    Generate ${numQuestions} questions of ${difficulty} difficulty.
    If the content is empty or there's no context for you to generate questions, 
    "questions" should be an empty array and 'preview' should tell the user to provide 
    a better document that is well-structured or scanned.
    
    Format the response as:
    {
      "preview": "A short summary of the content of the document",
      "questions": [
        { "question": "The question text", "difficulty": "${difficulty}", "correctAnswer": "The correct answer" }
      ]
    }
  `;

  return generateGeminiResponse(prompt);
};

// Validate user's answer
export const validateAnswer = async (question, correctAnswer, userAnswer) => {
  const prompt = `
    Question: ${question}
    Correct Answer: ${correctAnswer}
    User's Answer: ${userAnswer}

    Evaluate if the user's answer is correct. 
    The user's answer doesn't need to be word-for-word identical to the correct answer, 
    but it should capture the essence of the correct answer. 
    Provide your evaluation in the following format:
    {
      "result": "Correct" or "Incorrect",
      "explanation": "${correctAnswer}"
    }
  `;

  return generateGeminiResponse(prompt);
};

// Generate RAG response
export const generateRagResponse = async (query, context) => {
  const prompt = `
    Based on the following document content:
    ${context}
    
    Answer the following question:
    ${query}
    
    If the document content doesn't contain relevant information to answer the question,
    please respond with: "I don't have enough information from the provided documents to answer this question."
    
    Format your response in a clear and concise manner.
  `;

  return generateGeminiResponse(prompt, "text/plain");
};



================================================
FILE: server/src/services/vectorService.js
================================================
import { GoogleGenerativeAI } from "@google/generative-ai";
import { AppError } from "../middleware/errorMiddleware.js";

// Initialize GoogleGenerativeAI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const embeddingModel = genAI.getGenerativeModel({ model: "embedding-001" });

// Generate embeddings for text
export const generateEmbedding = async (text) => {
  try {
    const result = await embeddingModel.embedContent(text);
    return result.embedding.values;
  } catch (error) {
    console.error("Error generating embedding:", error);
    throw new AppError("Failed to generate embedding", 500);
  }
};

// Calculate cosine similarity between two embeddings
export const calculateCosineSimilarity = (embedding1, embedding2) => {
  // Calculate dot product
  const dotProduct = embedding1.reduce(
    (sum, value, i) => sum + value * embedding2[i],
    0
  );

  // Calculate magnitudes
  const magnitude1 = Math.sqrt(
    embedding1.reduce((sum, value) => sum + value * value, 0)
  );
  const magnitude2 = Math.sqrt(
    embedding2.reduce((sum, value) => sum + value * value, 0)
  );

  // Calculate cosine similarity
  return dotProduct / (magnitude1 * magnitude2);
};

// Chunk text into smaller segments
export const chunkText = (text, maxChunkSize = 1000) => {
  const words = text.split(" ");
  const chunks = [];
  let currentChunk = [];
  let currentSize = 0;

  for (const word of words) {
    if (
      currentSize + word.length + 1 > maxChunkSize &&
      currentChunk.length > 0
    ) {
      chunks.push(currentChunk.join(" "));
      currentChunk = [word];
      currentSize = word.length;
    } else {
      currentChunk.push(word);
      currentSize += word.length + 1; // +1 for the space
    }
  }

  if (currentChunk.length > 0) {
    chunks.push(currentChunk.join(" "));
  }

  return chunks;
};

// Find most relevant chunks for a query
export const findRelevantChunks = async (query, textChunks, topK = 3) => {
  try {
    // Generate embedding for the query
    const queryEmbedding = await generateEmbedding(query);

    // Generate embeddings for each chunk and calculate similarity
    const chunkSimilarities = await Promise.all(
      textChunks.map(async (chunk, index) => {
        const chunkEmbedding = await generateEmbedding(chunk);
        const similarity = calculateCosineSimilarity(
          queryEmbedding,
          chunkEmbedding
        );
        return { chunk, similarity, index };
      })
    );

    // Sort by similarity (descending)
    const sortedChunks = chunkSimilarities.sort(
      (a, b) => b.similarity - a.similarity
    );

    // Return top K chunks
    return sortedChunks.slice(0, topK);
  } catch (error) {
    console.error("Error finding relevant chunks:", error);
    throw new AppError("Failed to find relevant content", 500);
  }
};



================================================
FILE: server/src/utils/emailService.js
================================================
import nodemailer from "nodemailer";

// Create email transporter
export const createTransporter = () => {
  return nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USERNAME,
      pass: process.env.EMAIL_PASSWORD,
    },
  });
};

// Send email
export const sendEmail = async (options) => {
  const transporter = createTransporter();

  const mailOptions = {
    from: `${process.env.FROM_NAME} <${process.env.EMAIL_USERNAME}>`,
    to: options.email,
    subject: options.subject,
    html: options.html,
  };

  const info = await transporter.sendMail(mailOptions);
  return info;
};

// Send password reset OTP email
export const sendPasswordResetEmail = async (email, otp, name) => {
  return sendEmail({
    email,
    subject: "Password Reset OTP",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 5px;">
        <h2 style="color: #333;">Password Reset Request</h2>
        <p>Hello ${name},</p>
        <p>You recently requested to reset your password. Use the following OTP code to complete the process:</p>
        <div style="background-color: #f5f5f5; padding: 10px; text-align: center; font-size: 24px; letter-spacing: 5px; font-weight: bold; margin: 20px 0;">
          ${otp}
        </div>
        <p>This OTP is valid for 10 minutes.</p>
        <p>If you didn't request a password reset, please ignore this email or contact support if you have concerns.</p>
        <p>Best regards,<br/>Your App Team</p>
      </div>
    `,
  });
};

// Send welcome email after registration
export const sendWelcomeEmail = async (email, name) => {
  return sendEmail({
    email,
    subject: "Welcome to our platform!",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #eee; border-radius: 5px;">
        <h2 style="color: #333;">Welcome to Our Platform!</h2>
        <p>Hello ${name},</p>
        <p>Thank you for registering with us. We're excited to have you on board!</p>
        <p>With our platform, you can:</p>
        <ul>
          <li>Upload documents and extract information</li>
          <li>Generate questions from your documents</li>
          <li>Chat with your documents using RAG technology</li>
        </ul>
        <p>If you have any questions or need assistance, don't hesitate to contact our support team.</p>
        <p>Best regards,<br/>Your App Team</p>
      </div>
    `,
  });
};



================================================
FILE: server/src/utils/fileProcessing.js
================================================
import fs from "fs";
import path from "path";
import pdfParse from "pdf-parse";
import mammoth from "mammoth";
import { createWorker } from "tesseract.js";
import { fileURLToPath } from "url";
import { AppError } from "../middleware/errorMiddleware.js";

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure uploads directory exists
const uploadsDir = path.join(__dirname, "../uploads");
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Clean extracted text
export const cleanText = (text) => {
  return text.replace(/\s\s+/g, " ").replace(/\n+/g, " ").trim();
};

// Extract text from PDF
export const extractTextFromPDF = async (buffer) => {
  try {
    const data = await pdfParse(buffer);
    return data.text || "No text found in PDF.";
  } catch (error) {
    throw new AppError(`Error extracting text from PDF: ${error.message}`, 400);
  }
};

// Extract text from DOCX
export const extractTextFromDocx = async (buffer) => {
  try {
    const { value: text } = await mammoth.extractRawText({ buffer });
    return text || "No text found in DOCX.";
  } catch (error) {
    throw new AppError(
      `Error extracting text from DOCX: ${error.message}`,
      400
    );
  }
};

// Extract text from plain text file
export const extractTextFromTxt = (buffer) => {
  try {
    return buffer.toString("utf8");
  } catch (error) {
    throw new AppError(`Error extracting text from TXT: ${error.message}`, 400);
  }
};

// Extract text from image using OCR
export const extractTextFromImage = async (buffer, mimetype) => {
  const worker = await createWorker("eng");
  const supportedFormats = [
    "image/png",
    "image/jpg",
    "image/jpeg",
    "image/bmp",
    "image/tiff",
  ];

  if (!supportedFormats.includes(mimetype)) {
    throw new AppError(
      "Unsupported image format. Please use PNG, JPEG, BMP, or TIFF.",
      400
    );
  }

  try {
    const {
      data: { text },
    } = await worker.recognize(buffer);
    return text || "No text found in image.";
  } catch (error) {
    throw new AppError(`Error in OCR processing: ${error.message}`, 400);
  } finally {
    await worker.terminate();
  }
};

// Save file to disk
export const saveFileToDisk = async (file, userId) => {
  // Create user directory if it doesn't exist
  const userDir = path.join(uploadsDir, userId.toString());
  if (!fs.existsSync(userDir)) {
    fs.mkdirSync(userDir, { recursive: true });
  }

  // Generate unique filename
  const timestamp = Date.now();
  const uniqueFilename = `${timestamp}-${file.originalname.replace(
    /\s+/g,
    "_"
  )}`;
  const filePath = path.join(userDir, uniqueFilename);

  // Write file to disk
  return new Promise((resolve, reject) => {
    fs.writeFile(filePath, file.buffer, (err) => {
      if (err) {
        reject(new AppError(`Error saving file to disk: ${err.message}`, 500));
      } else {
        resolve({
          originalFileName: file.originalname,
          storagePath: filePath,
          fileType: file.mimetype,
          fileSize: file.size,
        });
      }
    });
  });
};

// Process file based on its type
export const processFile = async (file) => {
  const { buffer, mimetype } = file;
  let extractedText = "";

  if (mimetype === "application/pdf") {
    extractedText = await extractTextFromPDF(buffer);
  } else if (mimetype.startsWith("image/")) {
    extractedText = await extractTextFromImage(buffer, mimetype);
  } else if (mimetype === "text/plain") {
    extractedText = extractTextFromTxt(buffer);
  } else if (
    mimetype ===
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
    mimetype === "application/msword"
  ) {
    extractedText = await extractTextFromDocx(buffer);
  } else {
    throw new AppError("Unsupported file type", 400);
  }

  return cleanText(extractedText);
};



================================================
FILE: server/src/utils/tokenUtils.js
================================================
import jwt from "jsonwebtoken";

// Generate JWT token
export const generateToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE,
  });
};

// Generate refresh token
export const generateRefreshToken = (id) => {
  return jwt.sign({ id }, process.env.REFRESH_TOKEN_SECRET, {
    expiresIn: process.env.REFRESH_TOKEN_EXPIRE,
  });
};

// Verify refresh token
export const verifyRefreshToken = (token) => {
  return jwt.verify(token, process.env.REFRESH_TOKEN_SECRET);
};


